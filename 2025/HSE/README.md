# Семинар 1
## Задача 0
Вычислить префикс функцию строки "abacaba", вспомнить алгоритм Кнута-Морриса-Пратта

<details>
<summary>Решение</summary>
Префикс функция: 0 0 1 0 1 2 3

Пусть хотим найти все вхождения $p$ в $t$, тогда:
* склеим $p#t$, # - символ которого нет в $p$ и $t$.
* вычислим $\phi(p#t)
* Ищем позиции, где $\phi_i = |p|$
* Время работы алгоритма $\mathcal{O}(|p|+|t|)$
* В варианте, когда просто склеиваем строки потребление памяти также $\mathcal{O}(|p|+|t|)$.
</details>

## Задача 1
Реализовать алгоритм Кнута-Морриса-Пратта, какие тесты вы бы написали?

<details>
<summary>Решение</summary>
    
```
#include <iostream>
#include <vector>
#include <cassert>

std::vector<size_t> CalculatePreffixFunction(const std::string& text) {
    size_t n = text.length(); 
    std::vector<size_t> preffix_function(n, 0); 

    size_t len = 0;
    size_t i = 1;

    while (i < n) {
        if (text[i] == text[len]) {
            len++;
            preffix_function[i] = len;
            i++;
        } else if (len != 0) {
            len = preffix_function[len - 1];
        } else {
            preffix_function[i] = 0;
            i++;
        }
    }

    return preffix_function;
}

std::vector<size_t> FindAllOccurences(const std::string& pattern, const std::string& text) {
    std::string combined = pattern + "#" + text;
    std::vector<size_t> pi = CalculatePreffixFunction(combined);
    std::vector<size_t> result;
    
    size_t m = pattern.size();
    for (size_t i = m + 1; i < combined.size(); ++i) {
        if (pi[i] == m) {
            result.push_back(i - 2 * m);
        }
    }
    return result;
}

int main()
{
    { 
        std::vector<size_t> expected = {0, 0, 1, 0, 1, 2, 3};
        assert(CalculatePreffixFunction("abacaba") == expected);
    }

    {
        std::vector<size_t> expected = {};
        assert(CalculatePreffixFunction("") == expected);
    }

    {
        std::vector<size_t> expected = {0,1,2,3,4};
        assert(CalculatePreffixFunction("aaaaa") == expected);
    }
    return 0;
}
```
</details>

## Задача 2
Можно ли в КМП алгоритме обойтись $\mathcal{O}(|p|)$ памяти?

<details>
<summary>Решение</summary>
Да, можно, значение префикс функции в алгоритме КМП никогда не превышает $|p|$ в силу наличия символа #.
</details>

## Задача 3
Визуализировать КМП в виде автомата для паттерна abacaba(граф со стрелочками) и при помощи автомата найти все вхождения паттерна в текст abadcabacabacaba.

<details>
<summary>Решение</summary>

- Пусть **w = b₁...bₘ** -- искомая строка
- **Q = {0, 1, ..., m}** -- множество состояний
- **q₀ = 0** -- начальное состояние (автомат не прочел никакого символа)
- Один переход должен описывать одну итерацию алгоритма КМП

**Начальный переход:**
δ(0, a) = 
- 0, если a ≠ b₁
- 1, если a = b₁

**Далее:**
δ(j, a) = 
- δ(π(j), a), если a ≠ bⱼ₊₁
- j + 1, если a = bⱼ₊₁

Вершина $m$ -- терминальная.
Полученный автомат будет принимать все строки вида $*w$, что нам и нужно для поиска вхождений.

Также заметим, что каждый раз мы идем в максимальный <<суффикс текущего состояния>>, который можно прочесть в автомате.


**Для любознательных, формально что такое ДКА:**
Детерминированный конечный автомат $\mathcal{A}=(\Sigma, Q, q_0, \delta, F)$, где:
* $\Sigma$ - алфавит, конечное множество
* $Q$ - конечное множество состояний
* $q_0$ - начальное состояние
* $\delta: Q \times \Sigma \to Q$ - функция переходов (пример: $q \in Q, a \in \Sigma $ -- следующее состояние $\delta(q, a)$)
* $F \subseteq Q$ - множество принимаемых значений.

Для всякой входной строки $w = a_1, \ldots, a_l$, где $l \geq 0$ и $a_1,\ldots,al \in \Sigma$, вычисление -- по- следовательность состояний $p_0, p_1, \ldots, p_l$, где $p_0 = q_0$, и всякое следующее состояние $p_i$, где $i \in \{1, \ldots , l\}$, однозначно определено как $p_i = \delta(p_{i−1}, a_i)$.
    
Строка принимается, если последнее состояние принадлежит множеству F, иначе отвергается.
</details>

## Задача 4
Найти все префиксы строки $t$, являющиеся палиндромами за линейное время

<details>
<summary>Решение</summary>
Запишем $t$#$t^R$, вычислим преффикс-функцию
Далее нужно посмотреть, какие преффиксы конструкции $t$#$t^R$ равны каким суффиксам.
</details>

## Задача 5
Найти вхождения паттерна $p$ в $t$ с точностью до одной ошибки за линейное время.

<details>
<summary>Решение</summary>

- Рассмотрите p#t и $p^R$#$t^R$
- Не более чем одна ошибка в позиции i значит что мы должны найти префикс старующий в i и суффикс, оканчивающийся в $i+|p|-1$, и размер общего совпадения с $p$ хотя бы $|p|-1$.
- Также задачу можно решать бин поиском+хешами
</details>

## Задача 6
Найти число подстрок палиндромов строки $s$ за линейное время.

<details>
<summary>Решение</summary>

- Решим для палиндромов нечетной длины, вычислим массив cnt, где cnt[i] - число палиндромов с центром в $i$.
- Решаем алгоритмом, похожим на алгоритм поиска $z$-функции.
- Поддерживаем $l$, $r - самый правый и большой палиндром

При вычислении cnt[i], есть два кейса:
- Если $i \in [l, r]$ - инициализируем cnt[i] = min(cnt[l + r - i], r - i) и досчитываем ответ наивно, при необходимости обновим $l$,$r$
- Иначе считаем ответ наивно, при необходимости обновим $l$,$r$

Алгоритм работает за линейное время, так как каждый шаг наивного цикла гарантированно сдвигает $r$ хотя бы на $1$ вправо

Для палиндромов четных размеров, рассуждения аналогичны.

*Алгоритм называется алгоритмом Манакера*
</details>

## Задача 7
Вычислить $z$-функцию строки "abacaba"

<details>
<summary>Решение</summary>
Z-функция: 0 0 1 0 3 0 1

Можно использовать аналогично преффикс-функции для поиска паттернов в строке.
</details>
