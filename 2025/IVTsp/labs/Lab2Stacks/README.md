
# Важные примечания 
* **ВСЕ ГРАФИКИ СТРОИТЬ НА PYTHON, ЕСЛИ ПОДРАЗУМЕВАЕТСЯ ПОСТРОЕНИЕ НЕСКОЛЬКИХ ГРАФИКОВ ДЛЯ СРАВНЕНИЯ, ИХ СТОИТ РИСОВАТЬ НА ОДНОМ ПОЛОТНЕ, А НЕ ОТДЕЛЬНО**
* **ВСЕ ГРАФИКИ ДОЛЖНЫ БЫТЬ ПОДПИСАНЫ И ДОЛЖНЫ ИМЕТЬ ЛЕГЕНДУ, В СЛУЧАЕ ОТСУТСТВИЯ ПОДПИСЕЙ, ОЦЕНКА МОЖЕТ БЫТЬ СНИЖЕНА**
* **КОД ДОЛЖЕН БЫТЬ ЧИСТЫМ И АККУРАТНЫМ**
* **В СЛУЧАЕ УМЫШЛЕННЫХ ПОПЫТОК ОБМАНУТЬ СИСТЕМУ БУДУТ ВЫСТАВЛЕНЫ ОТРИЦАТЕЛЬНЫЕ БАЛЛЫ (списывание, попытка сдать лабу с чужими данными, попытка придумать данные вместо их честного измерения), цена наказания == -(балл за оштрафованное задание)**
* **В СЛУЧАЕ СПИСЫВАНИЯ КАРАЮТСЯ ВСЕ УЧАСТНИКИ СПИСЫВАНИЯ ВНЕ ЗАВИСИМОСТИ ОТ ТОГО, КТО И КОМУ ДАЛ СПИСАТЬ**
* **ПРИ ДОСРОЧНОМ ЧИСТОСЕРДЕЧНОМ ПРИЗНАНИИ СТАВИТСЯ 0Б, только тому человеку кто списал**
* **Должен быть скрипт(на bash либо python), который генерирует тесты и запускает построение всех нужных графиков, сами файлы тестов в репозиторий добавлять не нужно, это нужно чтобы проверяющий мог воспроизвести результаты**


# Практическая работа 2. "Сравнение скорости работы динамического массива и односвязного списка" (вес 14б.)

Необходимо написать динамический массив и односвязный список. 

Далее необходимо написать два стека: на списке и на массиве.


У стеков должны быть следующие функции:

* struct Stack* stack_ctr(size_t size, size_t element_size) 
создает массив заданного размера, который потом будет изменяться в ходе исполнения (только для массива)


* int push(struct Stack* st, void* buffer) 
Добавляет элемент в конец контейнера, возвращает 1 если добавление успешно, 0 - не успешно


* int top(struct Stack* st, void* buffer) 
Возвращает последний элемент


* int pop(struct Stack* st) 
Удаляет последний элемент, не возвращая его, возвращает 1 - если успех, 0 - если ошибка


* struct Stack* stack_dtr(struct Stack* st) 
Уничтожает контейнер, освобождая память, возвращает nullptr


## Далее провести для них следующие тесты (каждый провести хотя бы по три раза и усреднить время тестов):


### Тест 1 (4б)
Надо запушить  `10^6` интов, потом удалить половину элементов и запушить четверть - останется 750000 интов. Повторять удаление половины и вставку четверти, пока не останется в стеке меньше 100000 элементов (получится 9 итераций).

### Тест 2 (4б)
Надо запушить  `10^6` интов, потом 100 раз удалить 10000 элементов и добавить столько же. Далее как в первом тесте провести 9 итераций удаления-вставки и снова 100 раз удалить 10000 элементов и добавить столько же.

### Тест 3 (4б)
Надо научиться средствами языка генерировать случайные числа из множества {1,2}. Далее сначала довести размер стека до миллиона, а потом выполнить миллион инструкций следующего вида: каждое выпадение единицы добавлять элемент, а на двойку - попать из стека. Засекать время после доведения размера стека до миллиона.

### Тест 4 (2б)
Построить график time(n), где n - число вставок для стека на массиве. n итерировать с шагом 1000 от 1000 до `10^6`. 

## Вывод (2б)
Какой стек, по вашему мнению, лучше?
