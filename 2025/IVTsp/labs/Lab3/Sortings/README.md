# Cравнение сортировок

## Важные примечания, на которые стоит обратить внимание 
* **ВСЕ ГРАФИКИ СТРОИТЬ НА PYTHON**
* **ВСЕ ГРАФИКИ ДОЛЖНЫ БЫТЬ ПОДПИСАНЫ И ДОЛЖНЫ ИМЕТЬ ЛЕГЕНДУ, В СЛУЧАЕ ОТСУТСТВИЯ ПОДПИСЕЙ, ОЦЕНКА МОЖЕТ БЫТЬ СНИЖЕНА**
* **КОД ДОЛЖЕН БЫТЬ ЧИСТЫМ И АККУРАТНЫМ**
* **В СЛУЧАЕ УМЫШЛЕННЫХ ПОПЫТОК ОБМАНУТЬ СИСТЕМУ БУДУТ ВЫСТАВЛЕНЫ ОТРИЦАТЕЛЬНЫЕ БАЛЛЫ (списывание, попытка сдать лабу с чужими данными, попытка придумать данные вместо их честного измерения), цена наказания == -(балл за оштрафованное задание)**
* **В СЛУЧАЕ СПИСЫВАНИЯ КАРАЮТСЯ ВСЕ УЧАСТНИКИ СПИСЫВАНИЯ ВНЕ ЗАВИСИМОСТИ ОТ ТОГО, КТО И КОМУ ДАЛ СПИСАТЬ**
* **ПРИ ДОСРОЧНОМ ЧИСТОСЕРДЕЧНОМ ПРИЗНАНИИ СТАВИТСЯ 0Б, только тому человеку кто списал**
* **РЕЗУЛЬТАТЫ И ГРАФИКИ ОПИСЫВАЮТСЯ И ДОБАВЛЯЮТСЯ В README.md**
Данная лабораторная работа предполагает сравнение различных видов сортировок, а также попытку потягаться с библиотечной функцией `qsort`.

## Пункт $0$. Подготовка ($4$ б., при условии выполнения хотя бы пункта $1$)
### Генератор тестов
* Напишите программу, которая генерирует случайный массив **НЕОТРИЦАТЕЛЬНЫХ**, $32$-битных чисел чисел (элементы должны иметь равномерное распределение). Программа должна принимать два параметра в качестве аргументов командной строки: число элементов массива и ограничение на величину элемента.
* Напишите программу, которая просто сортирует массив из входного потока при помощи библиотечного `qsort`.
* Напишите `bash` скрипт, который по заданному размеру тестов (`from`, `to`, `step`) генерирует тесты c ответами к ним (ответы генерировать используя стандартный библиотечный `qsort`). Скрипт сохраняет тесты в заданную папку (можно сделать так, чтобы скрипт создавал папку). Формат названия файлов с тестами: **{size}_{k}.in**, **{size}_{k}.out**. Ответы пригодятся для валидации ваших сортировок. **При генерации тестов используйте перенаправление потоков ввода-вывода и две предыдущие программы**

### Подготовка к тестированию сортировок
* Напишите заголовочный файл `testing.h`, в нем реализуйте функцию для тестирования сортировок. Эта функция должна получать в качестве параметров путь к папке с тестами, указатель на функцию с нужной сортировкой, а также путь, куда сохранить результаты тестов.
* Функция должна считать, что файлы в папке тестов созданы по шаблону из пункта выше, в качестве доп. аргументов нужно принимать `from`, `to` и `step`, которые были использованы для генерации набора. Функция должна проверять, верно ли тестируемая функция сортирует массив на каждом тесте (если не верно, программа должна падать с `assert`-ом), функция должна возвращать массив усредненных времен (тип `double`, усредняем результаты для каждого размера массива), затраченных на каждый тест, замеряется только то время, которое тестируемая функция тратит на сортировку массива. 
* Реализации сортировок можно разбивать на файлы по своему усмотрению (из соображений адекватности, а не желания запутать проверяющего).
* Также напишите программу tester.c, которая будет запускать все необходимые тесты и сохранять результаты тестов в текстовые файлы. Выбор формата хранения остается за вами, например можно хранить числа через пробел, а можно хранить в формате csv.

### Генерируем тесты
**ВАЖНО! Тесты в репозиторий не добавляем, пушим только скрипт для генерации тестов**

Сгенерируйте три папки тестов:
* `small_tests` — тесты с массивами размера от $0$ до $1000$ с шагом $50$, ограничение MAX_RAND, тестов каждого размера $5$ штук;
* `big_tests` (тесты от $0$ до $1000000$ с шагом $10000$, ограничение MAX_RAND), тестов каждого размера $5$ штук;
* `test_most_dublicates` (тесты от $0$ до $1000000$ с шагом $10000$, ограничение значения элемента $10000$), тестов каждого размера $5$ штук.

**Если тестов не хватит для того, чтобы увидеть какие либо зависимости, можно увеличить их размеры, если на вашей машине работает слишком долго, можно уменьшить размеры тестов, не забудьте написать об этом в README.**

Папка c тестами дожна иметь примерно такое содержание:
* `0_0.in`
* `0_1.out`
* `0_2.in`
* `0_2.out`
* `0_3.in`
* `0_3.out`
* `...`
* `1000000_5.out`
  
**Так предлагается делать для упрощения проверки ваших работ, а также с таким неймингом тестов будет легко их прогонять**

**ВСЕ ФУНКЦИИ СОРТИРОВКИ ДОЛЖНЫ ОБЛАДАТЬ СЛЕДУЮЩЕЙ СИГНАТУРОЙ**

```void {название сортировки}_sort(int* arr, size_t n);```

Название сортировки стоит указывать так, чтобы ревьювер понимал, какая сортировка реализована.

## Пункт $1$. Квадратичные (и не совсем) сортировки ($4$ б. + $2$* б.)
Напишите $4$ сортировки:
* Вставками;
* Пузырьком;
* Выбором;
* Сортировка Шелла (в качестве стратегии для выбора шагов используйте последовательность Кнута, которая обсуждалась на лекции.

Все сортировки должны ипользовать $O(1)$ памяти и время соответствующее теории (у всех кроме Шелла $O(n^2)$).

Задание со * на дополнительные $2$ б.: 
[Сортировка Шелла](https://en.wikipedia.org/wiki/Shellsort)
Выберите дополнительно несколько стратегий с таблицы на википедии($3$-$4$ штуки), которые вас заинтересовали и включите их в сравнение.

**Все сортировки тестировать на **ОДИНАКОВОМ** наборе массивов `small_tests`, полученных при помощи скрипта из пункта $0$.**

Построить график для каждой сортировки (по оси $x$ --- размер массива, по оси $y$ ---  затраченное время "в среднем" для массивов этого размера). 
**Поскольку мы сравниваем несколько графиков, строить их стоит на общей системе координат, не нужно строить отдельно $4$ графика**

По результатам экперимента ответить на вопрос: *Какая сортировка в итоге показала себя лучше всех остальных?*

## Пункт $2$. Пирамидальные сортировки ($3$ б.)
**Принимается исключительно Bottom-Up версия пирамидальной сортировки, на семинарах уже сравнивались классический вариант heapSort и Bottom-Up heapSort, не нужно это делать отдельно в работе**
**Сортировка должна использовать $O(1)$ доп памяти, стековую память также использовать запрещается (то есть рекурсию не используем)**

Напишите пирамидальную сортировку, основанную на $k$-ичной куче (использовать параметр $k$ -- число детей узла кучи) и постройте графики на наборе `big_tests` для $k$ от $2$ до $10$ (по оси $x$ -- размер массива, по оси $y$ --  затраченное время "в среднем" для массивов этого размера).. 
**Поскольку мы сравниваем несколько графиков, строить их стоит на общей системе координат, не нужно строить отдельно нескольео графиков**

По результатам экперимента ответить на вопрос: *Какое $k$ оказалось оптимальным?* 

## Пункт $3$. Сортировка слиянием ($3$ б.)
* Написать рекурсивную версию сортировки слиянием.
* Написать итеративную версию сортировки слиянием.

Сравниваем тоже на наборе данных `big_tests`.

Постройте график на котором отображены оба варианта сортировок (по оси $x$ -- размер массива, по оси $y$ --  затраченное время "в среднем" для массивов этого размера).
*рисовать все линии на одном графике, так их проще сравнивать*

По результатам экперимента ответить на вопрос: *Какой вариант работает лучше? Как думаете почему?* 

## Пункт $4$. Быстрые сортировки (партиционирования и оптимизации) ($8$ б.)
Напишите $3$ вида партиционирования и быстрые сортировки (в качестве опорного берите центральный элемент сортируемого отрезка), использующие их:
* Ломуто;
* Хоара;
* Толстое разбиение.

**рекомендация: во избежание тотальной копипасты принимайте функцию `partition` и `pivot_selector` как указатели на функции.**

Сравните на наборе данных `big_tests`, также сравните на наборе `test_most_dublicates`:
Постройте график на котором отображены три сортировки (по оси $x$ -- размер массива, по оси $y$ --  затраченное время "в среднем" для массивов этого размера).

*рисовать все линии на одном графике, так их проще сравнивать*

* Рекурсия с одной веткой
* Опционально: реализация вовсе без рекурсии(можно взять стек из прошлой лабараторной работы) ($+2$ б.)
Сравните на наборе данных `big_tests`:
Постройте график на котором отображена лучшая из трех сортировок и две попытки ее оптимизации (по оси $x$ -- размер массива, по оси $y$ --  затраченное время "в среднем" для массивов этого размера).

По результатам экпериментов ответить на вопрос: *Что работает лучше? Как думаете почему?* 

**Опять же напомним что стрит рисовать все линии на одном графике, так их проще сравнивать**

## Пункт $5$. Быстрые сортировки (разные стратегии выбора, прочее) ($4$ б. + $3$* б.)
Сравните на наборе данных `big_tests` следующие стратегии выбора `pivot`. В качестве базовой сортировки возьмите лучшую сортировку из предыдущего пункта.
* Центральный элемент
* Медиана 3
* Случайный элемент
* Медиана трех случайных
* Опционально: медиана медиан(при реализации этого пункта, запрещено заводить массив для поиска медианы медиан) (+$3$ б.)
Сравните на наборе данных big_tests(по оси x -- размер массива, по оси y --  затраченное время "в среднем" для массивов этого размера),

**Рисовать все линии на одном графике, так их проще сравнивать**

## Пункт $6$. Выбор размера блоков для Introsort ($2$ б.)
Часто, алгоритмы имеющие хорошую теоретическую оценку сложности проигрывают на данных малого размера. Цель этого пункта подобрать оптимальный размер сортируемого блока малого размера. В `Introsort` маленькие блоки сортируются при помощи сортировки вставками (или Шелла), цель этого пункта, определить размер при котором выбранная сортировка дает максимальную победу.
* Выберите самую быструю из всех быстрых сортировок, которые вы написали и протестировали
* Выберите самую быструю сортировку из пункта $1$
* Внедрите сортировку из пункта $1$ в быструю при блоках размера $t$, где $t$ - параметр, который мы будем перебирать.
* Диапазон перебора за вами.
Сравнивать будем на наборе `big_tests`:

Постройте графики, с разными $t$. (по оси $x$ -- размер массива, по оси $y$ --  затраченное время "в среднем" для массивов этого размера)

**Рисовать все линии на одном графике, так их проще сравнивать**

Ответить на вопрос: какой размер оптимален для блока?

## Пункт $7$. Introspective Sorting ($6$ б.)
Напишите интроспективную сортировку, которая использует:
* Оптимальную квадратичную сортировку для малых блоков
* Пирамидальную сортировку с оптимальным $k$, когда рекурсия достигает глубины $C\log{n}$, оптимальный коэффициент $C$ можно подобрать экспериментально (также построить график $T(C)$). 
* в качестве основного метода сортировки использовать самую удачную быструю сортировку из пункта $5$

Сравнивать будем на наборе `big_tests`:
Постройте график, в котором участвуют: ваша оптимальная быстрая сортировка, Introspective Sorting (по оси $x$ -- размер массива, по оси $y$ --  затраченное время "в среднем" для массивов этого размера).

*рисовать все линии на одном графике, так их проще сравнивать*

Ответить на вопрос: стало ли работать лучше?

## Пункт $8$. Timsort+PDQSort ($5$* б. + $15$* б.)
* Добавить к сравнению из пункта $7$ `Timsort` + `PDQSort` (можно использовать любые готовые с гитхаба, если не найдете на си, допускается взять `c++` вариант), за это $5$ баллов
* Реализуйте *САМОСТОЯТЕЛЬНО* `Timsort` и `PDQSort` и добавить в сравнени. *За это еще* $15$ *бонусных баллов*

## Пункт $9$. Сортировки, основанные не на сравнениях ($8$ б.)
Реализуйте Least Significant Digit Sort и Most Significant Digit Sort по байтам.
Ответить на вопрос: какая сортировка работает лучше?

Сравнивать будем на наборе `big_tests`:
Постройте график, в котором участвуют эти две сортировки (по оси $x$ -- размер массива, по оси $y$ --  затраченное время "в среднем" для массивов этого размера).

*рисовать все линии на одном графике, так их проще сравнивать*

Ответить на вопрос: какая работает лучше?

## Пункт $10$. Вывод ($4$ б.)

**Вывод может может получить полные $4$ б. тогда и только тогда, когда реализованы все пункты, кроме опциональных**

Постройте график (для набора `big_tests`), в котором участвуют лучшие сортировки из пунктов $2$ - $5$, $7$ - $8$, а также `qsort` из стандартной библиотеки языка Си (по оси $x$ -- размер массива, по оси $y$ --  затраченное время "в среднем" для массивов этого размера).

*рисовать все линии на одном графике, так их проще сравнивать*

**Напишите развернутый вывод о проведенном исследовании и полученных результатах, также уточните удалось ли догнать стандартный алгоритм сортировки или хотя бы приблизиться к нему, также укажите CPU, на котором выполнялись тесты**

