# Хеширование 

## Исследование Хеш-функций
Сгенерируйте 1000000 случайных ключей(__ТОГО ТИПА ДАННЫХ, ДЛЯ КОТОРОГО ПРЕДНАЗНАЧЕНА ХЕШ-ФУНКЦИЯ__) и постройте столбчатые диаграммы коллизий для хеш-функции. Также для каждого теста измерить время и сделать таблицу. __ФАЙЛЫ С ТЕСТАМИ В РЕПОЗИТОРИЙ НЕ ЗАГРУЖАЕМ, однако загружаем скрипт, с помощью которого был получен набор; srand в качестве seed передать 42__

Брать остаток от деления на 1000.

Для сравнения похожих визуально столбчатых диаграмм используйте следующий метод сравнения: посчитайте дисперсию высот столбиков. Какой она должна быть, если столбики имеют одинаковую высоту?

### Целые числа (unsigned int) (3 б.)
Генерировать числа из равномерного распределения `[0, RAND_MAX]`.

1) Остаток от деления
2) Битовое представление
3) Метод умножения с константой $A$, предложенной Кнутом (Томас Кормен стр. 296).

__Напишите выводы о том, как себя ведет каждая из функций.__

### Числа с плавающей точкой (float) (5 б.)
Генерировать числа из равномерного распределения `[-10, 10]`.
1) Преобразование к (int) c последующим взятием битого представления int
2) Битовое представление
3) Извлечение мантиссы 
4) Извлечение экспоненты 
5) Произведение мантиссы на экспоненту.

__Напишите выводы о том, как себя ведет каждая из функций и ваши мысли, почему так получилось. Стоит ли вообще хешировать числа с плавающей точкой?__

### Строки (4 б.)
Генерировать строки случайной длины от 5 до 20 символов, из случайных малых букв английского алфавита.

1) Длина строки
2) Сумма букв
3) Полиномиальный
4) [crc32](https://github.com/gcc-mirror/gcc/blob/master/libiberty/crc32.c)

__Напишите выводы о том, как себя ведет каждая из функций и ваши мысли, почему так получилось.__
## Сравнение Хеш-таблиц (20 б.)
__В этом пункте все хеш таблицы должны работать с числами типа int. Делать rehash при достижении большого load_factor.__

Реализуйте следующие таблицы:
* Хеширование цепочками
* Используйте открытое хеширование с линейным тестированием
* Используйте открытое хеширование с квадратичным тестированием
* Используйте открытое хеширование с методом двойного хеширования
* Хеширование кукушки

Строим следующие графики:
1) Зависимость времени работы хеш-таблицы от выбранного load_factor, для 1 млн случайных вставок.
Далее выберите подходящий load_factor (разумно)

2) Сгенерируйте случайную последовательность операций с хеш-таблицей (вставка, поиск, удаление); все операции считать равновероятными.
Размеры тестов: 10000, 1000000, шаг 10000, засеките время и постройте графики. 

3) Пункт 2, когда вероятность вставки 0.5, а - и ? - 0.25 каждая

__Напишите выводы о том, как себя ведет каждая из хеш-таблиц, и какой load factor лучше выбрать для рехеширования, а также ваши мысли, почему так получилось.__
## Сравнение идеального хеширования с обычным (15 б.)
Построить три хеш-таблицы из случайного набора на 100000 различных чисел типа int:
* С методом цепочек
* Победитель из прошлого пункта с методом открытого хеширования
* Хеширование кукушки
* Хеш-таблицу, использующую __идеальное хеширование__

Сделайте 10 млн запросов поиска к каждой из хеш-таблиц.

Составить таблицу и написать выводы. Есть ли смысл в идеальном хешировании?

__Творческое задание на +10 б.__: придумать метод и сравнить задержки при поиске (время ожидания результата поиска), которые могут возникать при использовании открытого хеширования и хеширования кукушки.

## Вывод (4б)
Напишите развернутые выводы.
