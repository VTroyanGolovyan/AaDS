# Хэширование 

## Исследование Хэш-Функций
Сгенерируйте 1000000 случайных ключей(__ТОГО ТИПА ДАННЫХ ДЛЯ КОТОРОГО ПРЕДНАЗНАЧЕНА ХЭШ ФУНКЦИЯ__), и постройте столбчатые диаграммы коллизий для хэш-функции, также для каждого теста измерить время и сделать таблицу. __ФАЙЛЫ С ТЕСТАМИ В РЕПОЗИТОРИЙ НЕ ЗАГРУЖАЕМ, однако загружаем скрипт, с помощью которого был получен набор, srand в качестве seed передать 42__

Брать остаток от деления на 1000.

Для сравнения похожих визуально столбчатых диаграмм используйте следующий метод сравнения: посчитайте дисперсию высот столбиков, какой она должна быть если столбики имеют одинаковую высоту?

### Целые числа (unsigned int) (3 б.)
Генерировать числа из равномерного распределения $[0, RAND MAX]$.

1) Остаток от деления
2) Битовое представление
3) Метод умножения с константой $A$, предложенной Кнутом (Томас Кормен стр. 296).
__Напишите выводы о том, как себя ведет каждая из функций__

### Числа с плавающей точкой (float) (5 б.)
Генерировать числа из равномерного распределения $[-10, 10]$.
1) Преобразование к (int) c последующим взятием битого представления инта
2) Битовое представление
3) Извлечение мантиссы 
4) Извлечение экспоненты 
5) Произведение мантиссы на экспоненту.
__Напишите выводы о том, как себя ведет каждая из функций и ваши мысли, почему так получилось. Стоит ли вообще хэшировать числа с плавающей точкой?__

### Строки (4 б.)
Генерировать строки случайной длины от 5 до 20 символов, из случайных малых букв английского алфавита.

1) Длинна строки
2) Сумма букв
3) Полиномиальный
4) [crc32](https://github.com/gcc-mirror/gcc/blob/master/libiberty/crc32.c)

__Напишите выводы о том, как себя ведет каждая из функций и ваши мысли, почему так получилось__
## Сравнение Хэш-таблиц (20 б.)
__В этом пункте все хэш таблицы должны работать с числами типа int, и делать rehash при достижении большого load_factor.__

Реализуйте следующие таблицы:
* Хэширование цепочками
* Используйте открытое хэширование с линейным тестированием
* Используйте открытое хэширование с квадратичным тестированием
* Используйте открытое хэширование с методом двойного хэширования
* Хэширование кукушки

Строим следующие графики:
1) Зависимость времени работы хэш-таблицы от выбранного load_factor, для 1млн случайных вставок.
Далее выберите подходящий load_factor (разумно)

2) Сгенерируйте случайную последовательность операций с хэш-таблицей (вставка, поиск, удаление), все операции считать равновероятными.
Размеры тестов: 10000, 1000000, шаг 10000, засеките время и постройте графики. 

3) Пункт 2, когда вероятность вставки 0.5, а - и ? - 0.25 каждая

__Напишите выводы о том, как себя ведет каждая из хэш-таблиц, и какой load factor лучше выбрать для рехеширования, а также ваши мысли, почему так получилось.__
## Сравнение идеального хэширования с обычным (15 б.)
Построить три хэш таблицы из случайного набора на 100000 различных чисел типа int:
* С методом цепочек
* Победительница из прошлого пункта с методом открытого хэширования
* Хэширование кукушки
* Хэш-таблицу, использующую __идеальное хэширование__

Сделайте 10 млн. запросов поиска к каждой из хэш-таблиц.

Составить таблицу и написать выводы. Есть ли смысл в идеальном хэшировании?

Творческое задание на +10 б: придумать метод и сравнить задержки при поиске(время ожидания результата поиска), которые могут возникать при использовании открытого хэширования и кукушкиного хэширования.

## Вывод (4б)
Напишите развернутые выводы.
