# Cравнение сортировок
Данная лабараторная работа предполагает сравнение различных видов сортировок, а также попытку потягаться с библиотечной функцией qsort.

## Пункт 0. Подготовка (4 б., при условии выполнения хотя бы пункта 1)
### Генератор тестов
* Напишите программу, которая генерирует случайный массив **НЕОТРИЦАТЕЛЬНЫХ** чисел (элементы должны иметь равномерное распределение). Программа должна принимать два параметра в качестве аргументов командной строки: число элементов массива и ограничение на величину элемента.
* Напишите программу, которая просто сортирует массив из входного потока при помощи библиотечного qsort.
* Напишите bash скрипт, который по заданному размеру тестов (from, to, step) генерирует тесты c ответами к ним (ответы генерировать используя стандартный библиотечный qsort).  Скрипт сохраняет тесты в заданную папку (можно сделать так, чтобы скрипт создавал папку). Формат названия файлов с тестами: **{size}_{k}.in**, **{size}_{k}.out**. Ответы пригодятся для валидации ваших сортировок. **При генерации тестов используйте перенаправление потоков ввода-вывода и две предыдущие программы**

### Подготовка к тестированию сортировок
* Напишите заголовочный файл testing.h, в нем реализуйте функцию для тестирования сортировок(она должна получать путь к папке с тестами, указатель на функцию с нужной сортировкой, а также путь куда сохранить результаты тестов).
* Функция должна считать что файлы в папке тестов созданы по шаблону из пункта выше, в качестве доп. аргументов нужно принимать from, to и step, которые были использованы для генерации набора. Функция должна проверять, верно ли тестируемая функция сортирует массив на каждом тесте(если не верно программа должна падать с assert-ом), функция должна возвращать массив времен(double), затраченных на каждый тест. 
* Реализации сортировок можно разбивать на файлы по своему усмотрению(из соображений адекватности, а не желания запутать проверяющего).
* Также напишите программу tester.c, которая будет запускать все необходимые тесты и сохранять результаты тестов в текстовые файлы(можно просто числа через пробел, можно csv)


### Генерируем тесты
Сгенерируйте четыре папки тестов:
* very_small_tests -- тесты с массивами размера от 1 до 150 с шагом 1, ограничение MAX_RAND, тестов каждого размера 5
* small_tests -- тесты с массивами размера от 0 до 1000 с шагом 50, ограничение MAX_RAND, тестов каждого размера 5
* big_tests (тесты от 0 до 1000000 с шагом 10000, ограничение MAX_RAND)
* test_most_dublicates (тесты от 0 до 1000000 с шагом 50, ограничение значения элемента 10000)

Папка c тестами дожна иметь примерно такое содержание:
* 0_0.in
* 0_1.out
* 0_2.in
* 0_2.out
* 0_3.in
* 0_3.out
* ...
* 1000000_5.out

** Так предлагается делать для упрощения проверки ваших работ, а также с таким неймингом тестов будет легко их прогонять**

**ВСЕ ФУНКЦИИ СОРТИРОВКИ ДОЛЖНЫ ОБЛАДАТЬ СЛЕДУЮЩЕЙ СИГНАТУРОЙ**
void {название сортировки}_sort(int* arr, size_t n);
название сортировки стоит указывать так, чтобы отвлеченный читатель понимал, какая сортировка реализована.

# Важные примечания 
* **ВСЕ ГРАФИКИ СТРОИТЬ НА PYTHON**
* **ВСЕ ГРАФИКИ ДОЛЖНЫ БЫТЬ ПОДПИСАНЫ И ДОЛЖНЫ ИМЕТЬ ЛЕГЕНДУ, В СЛУЧАЕ ОТСУТСТВИЯ ПОДПИСЕЙ, ОЦЕНКА МОЖЕТ БЫТЬ СНИЖЕНА**
* **КОД ДОЛЖЕН БЫТЬ ЧИСТЫМ И АККУРАТНЫМ**
* **В СЛУЧАЕ УМЫШЛЕННЫХ ПОПЫТОК ОБМАНУТЬ СИСТЕМУ БУДУТ ВЫСТАВЛЕНЫ ОТРИЦАТЕЛЬНЫЕ БАЛЛЫ (списывание, попытка сдать лабу с чужими данными, попытка придумать данные вместо их честного измерения), цена наказания == -(балл за оштрафованное задание)**
* **В СЛУЧАЕ СПИСЫВАНИЯ КАРАЮТСЯ ВСЕ УЧАСТНИКИ СПИСЫВАНИЯ ВНЕ ЗАВИСИМОСТИ ОТ ТОГО, КТО И КОМУ ДАЛ СПИСАТЬ**
* **ПРИ ДОСРОЧНОМ ЧИСТОСЕРДЕЧНОМ ПРИЗНАНИИ СТАВИТСЯ 0Б, только тому человеку кто списал**

## Пункт 1. Квадратичные (и не совсем) сортировки (4 б.).
Напишите 4 сортировки:
* вставками
* пузырьком
* выбором
* сортировка Шелла (в качестве стратегии для выбора шагов используйте последовательность, которая обсуждалась на лекции)
Все сортировки должны ипользовать $O(1)$ памяти и время соответствующее теории (у всех кроме Шелла $O(n^2)$).

Задание со *(+2б): 
https://en.wikipedia.org/wiki/Shellsort
Выберите дополнительно несколько стратегий с таблицы на википедии(3-4 штуки), которые вас заинтересовали и включите их в сравнение.

*Все сортировки тестировать на **ОДИНАКОВОМ** наборе массивов, полученных при помощи скрипта из пункта 0 следующего вида:*

Построить график для каждой сортировки (по оси x -- размер массива, по оси y --  затраченное время "в среднем" для массивов этого размера). 

*Ответить на вопрос:* Какая в сортировка в итоге отработала лучше всех?

## Пункт 2. Пирамидальная сортировка (3 б.)
Напишите пирамидальную сортировку, основанную на $k$-ичной куче (добавить параметр $k$ -- число детей кучи).
*Сортировка должна использовать $O(1)$ доп памяти, стековую память также использовать запрещается*

*рисовать все линии на одном графике, так их проще сравнивать*

*Ответить на вопрос:* Какое $k$ оказалось оптимальным?

## Пункт 3. Сортировка слиянием. Пирамидальная сортировка (3 б.)
* Написать рекурсивную версию сортировки слиянием
* Написать итеративную версию сортировки слиянием
Сравните на наборе данных big_tests
Постройте график на котором отображены оба варианта сортировок(по оси x -- размер массива, по оси y --  затраченное время "в среднем" для массивов этого размера).
*рисовать все линии на одном графике, так их проще сравнивать*

*Ответить на вопрос:* Какой вариант работает лучше?

## Пункт 4. Быстрые сортировки (партиционирования и оптимизации) (8 б.)
Напишите 3 вида партиционирования и быстрые сортировки (в качестве опорного берите центральный элемент сортируемого отрезка), использующие их:
* Ломуто
* Хоара
* Толстое разбиение

Сравните на наборе данных big_tests, также сравните на наборе test_most_dublicates:
Постройте график на котором отображены три сортировки (по оси x -- размер массива, по оси y --  затраченное время "в среднем" для массивов этого размера).

*рисовать все линии на одном графике, так их проще сравнивать*

* Рекурсия с одной веткой
* Опционально: реализация вовсе без рекурсии(можно взять стек из прошлой лабараторной работы) (+2 б.)
Сравните на наборе данных big_tests:
Постройте график на котором отображена лучшая из трех сортировок и две попытки ее оптимизации (по оси x -- размер массива, по оси y --  затраченное время "в среднем" для массивов этого размера).

*рисовать все линии на одном графике, так их проще сравнивать*

## Пункт 5. Быстрые сортировки (разные стратегии выбора, прочее) (4 б.)
Сравните на наборе данных big_tests следующие стратегии выбора pivot. В качестве базовой сортировки возьмите лучшую сортировку из предыдущего пункта.
* Центральный элемент
* Медиана 3
* Случайный элемент
* Медиана трех случайных
* Опционально: медиана медиан(при реализации этого пункта, запрещено заводить массив для поиска медианы медиан)(+3 б.)
Сравните на наборе данных big_tests(по оси x -- размер массива, по оси y --  затраченное время "в среднем" для массивов этого размера),

*рисовать все линии на одном графике, так их проще сравнивать*

## Пункт 6. Выбор размера блоков для Introsort (2 б.)
Часто, алгоритмы имеющие хорошую теоретическую оценку сложности проигрывают на данных малого размера. Цель этого пункта подобрать оптимальный размер сортируемого блока малого размера. В Introsort маленькие блоки сортируются при помощи сортировки вставками(Шелла), цель этого пункта, определить размер при котором выбранная сортировка работает быстрее, чем быстрая.
* Выберите самую быструю из всех быстрых сортировок, которые вы написали и протестировали
* Выберите самую быструю сортировку из пункта 1
Сравнивать будем на наборе very_small_tests:
Постройте график, в котором участвуют результаты для обоих сортировок. (по оси x -- размер массива, по оси y --  затраченное время "в среднем" для массивов этого размера)
*рисовать все линии на одном графике, так их проще сравнивать*

Ответить на вопрос: какой размер оптимален для блока?

## Пункт 7. Introspective Sorting (6 б.)
Напишите интроспективную сортировку, которая использует:
* Оптимальную квадратичную сортировку для малых блоков
* Пирамидальную сортировку с оптимальным $k$, когда рекурсия достигает глубины $\log{n}$
* в качестве основного метода сортировки использовать самую удачную быструю сортировку из пункта 5
Сравнивать будем на наборе big_tests:
Постройте график, в котором участвуют: ваша оптимальная быстрая сортировка, Introspective Sorting(по оси x -- размер массива, по оси y --  затраченное время "в среднем" для массивов этого размера).

*рисовать все линии на одном графике, так их проще сравнивать*

Ответить на вопрос: стало ли работать лучше?

## Пункт 8. Сортировки, основанные не на сравнениях (8 б.)
Реализуйте Last Significant Digit Sort, и Most Significant Digit Sort по байтам.

Ответить на вопрос: какая сортировка работает лучше?

Сравнивать будем на наборе big_tests:
Постройте график, в котором участвуют эти две сортировки (по оси x -- размер массива, по оси y --  затраченное время "в среднем" для массивов этого размера).

*рисовать все линии на одном графике, так их проще сравнивать*

Ответить на вопрос: какая работает лучше?

## Пункт 9. Вывод (4 б.)

**Вывод может может получить полные 4 б. тогда и только тогда, когда реализованы все пункты, кроме опциональных**

Постройте график (для набора big_tests), в котором участвуют лучшие сортировки из пунктов 2-5, 7-8, а также qsort из стандартной библиотеки языка Си(по оси x -- размер массива, по оси y --  затраченное время "в среднем" для массивов этого размера).

*рисовать все линии на одном графике, так их проще сравнивать*

**Напишите развернутый вывод о проведенном исследовании и полученных результатах, также уточните удалось ли догнать стандартный алгоритм сортировки или хотя бы приблизиться к нему**

