# Cравнение сортировок
Данная лабараторная работа предполагает сравнение различных видов сортировок, а также попытку потягаться с библиотесной функцией qsort.

# Пункт 0. Подготовка (4 б., при условии выполнения хотя бы пункта 1).
## Генератор тестов
* Напишите программу, которая генерирует случайный массив НЕОТРИЦАТЕЛЬНЫХ чисел (элементы должны иметь равномерное распределение). Программа должна принимать два параметра через аргументы командной строки: число элементов массива, ограничение на величину элемента(по модулю)
* Напишите bash скрипт, который по заданному размеру тестов(from, to, step) генерирует тесты и ответы к ним(ответы генерировать используя стандартный библиотечный qsort).  Скрипт складывает тесты в заданную папку(можно сделать так, чтобы скрипт создавал папку), формат названия {size}_{k}.in, {size}_{k}.out. Ответы пригодятся для валидации ваших сортировок.
## Подготовка к тестированию сортировок
* Напишите заголовочный файл testing.h, в нем реализуйте функцию для тестирования сортировок(она должна получать путь к папке с тестами, указатель на функцию с нужной сортировкой, а также путь куда сохранить результаты тестов). Функция должна считать что файлы в папке тестов созданы по шаблону из пункта выше, в качестве доп. аргументов нужно принимать from, to и step, которые были использованы для генерации набора. Функция должна проверять, верно ли тестируемая функция сортирует массив на каждом тесте(если не верно программа должна падать с assert-ом), функция должна возвращать массив времен(double), затраченных на каждый тест. 
* Реализации сортировок можно разбивать на файлы по своему усмотрению(из соображений адекватности, а не желания запутать проверяющего).
* Также напишите программу tester.c, которая будет запускать все необходимые тесты и сохранять необходимые результаты тестов в текстовые файлы
## Генерируем тесты
Сгенерируйте четыре папки тестов:
* very_small_tests -- тесты с массивами размера от 1 до 150 с шагом 1, ограничение MAX_RAND, тестов каждого размера 5
* small_tests -- тесты с массивами размера от 0 до 1000 с шагом 50, ограничение MAX_RAND, тестов каждого размера 5
* big_tests (тесты от 0 до 1000000 с шагом 50, ограничение MAX_RAND)
* test_most_dublicates (тесты от 0 до 1000000 с шагом 50, ограничение значения элемента 10000)

Папка small_tests дожна иметь примерно такое содержание:
* 0_0.in
* 0_1.out
* 0_2.in
* 0_2.out
* 0_3.in
* 0_3.out
* ...
* 1000000_5.out

*ВСЕ ФУНКЦИИ СОРТИРОВКИ ДОЛЖНЫ ОБЛАДАТЬ СЛЕДУЮЩЕЙ СИГНАТУРОЙ*
void {название сортировки}_sort(int* arr, size_t n);
название сортировки стоит указывать так, чтобы отвлеченный читатель понимал, какая сортировка реализована.

## Пункт 1. Квадратичные (и не совсем) сортировки (4 б.).
Напишите 4 сортировки:
* вставками
* пузырьком
* выбором
* сортировка Шелла (в качестве стратегии для выбора шагов используйте последовательность, которая обсуждалась на лекции)
Все сортировки должны ипользовать $O(1)$ памяти и время соответствующее теории (у всех кроме Шелла $O(n^2)$).

Задание со *(+2б): 
https://en.wikipedia.org/wiki/Shellsort
Выберите дополнительно несколько стратегий с таблицы на википедии(3-4 штуки), которые вас заинтересовали и включите их в сравнение.

*Все сортировки тестировать на ОДИНАКОВОМ наборе массивов, полученных при помощи скрипта из пункта 0 следующего вида:*

Построить график для каждой сортировки (по оси x -- размер массива, по оси y --  затраченное время "в среднем" для массивов этого размера). 

*Ответить на вопрос:* Какая в сортировка в итоге отработала лучше всех?

## Пункт 2. Пирамидальная сортировка (3 б.)
Напишите пирамидальную сортировку, основанную на $k$-ичной куче (добавить параметр $k$ -- число детей кучи).
*Сортировка должна использовать $O(1)$ доп памяти, стековую память также использовать запрещается*

*Ответить на вопрос:* Какое $k$ оказалось оптимальным?

## Пункт 3. Сортировка слиянием. Пирамидальная сортировка (3 б.)
* Написать рекурсивную версию сортировки слиянием
* Написать итеративную версию сортировки слиянием

*Ответить на вопрос:* Какой вариант работает лучше?

## Пункт 4. Быстрые сортировки (разные партиционирования) (8б)
Напишите 3 вида партиционирования и быстрые сортировки, использующие их
* Ломуто
* Хоара
* Толстое разбиение
Сравните.

## Пункт 5. Быстрые сортировки (разные стратегии выбора и прочие оптимизации)

## Пункт 6. Выбор размера блоков для Introsort (2б)
Часто, алгоритмы имеющие хорошую теоретическую оценку сложности проигрывают на данных малого размера. Цель этого пункта подобрать оптимальный размер сортируемого блока малого размера.


## Пункт 5. Introspective Sorting
Напишите интроспективную сортировку, которая использует:
* Оптимальную квадратичную сортировку для малых блоков
* Пирамидальную сортировку с оптимальным $k$, когда рекурсия достигает глубины $\log{n}$
* 
